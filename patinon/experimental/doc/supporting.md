% Supporting Material and References
% J. Alex Stark
% 2003--2022


----------------------------------------

Heptodes documents and other content in `doc` directories are licensed under the
[Creative Commons Attribution 4.0 License] (CC BY 4.0 license).

Source code licensed and code samples are licensed under the [Apache
2.0 License].

The CC BY 4.0 license requires attribution.  When samples, examples, figures,
tables, or other excerpts, are used in a tutorial, or a subdivision thereof, it
is sufficient to provide the complete source and license information once.  This
must be close to the beginning, such as in an early acknowledgments slide.  If
this is done, only short notes are required to be placed with each usage, such
as in figure captions.

[Creative Commons Attribution 4.0 License]: https://creativecommons.org/licenses/by/4.0/legalcode
[Apache 2.0 License]: https://www.apache.org/licenses/LICENSE-2.0

----------------------------------------


# Supporting material and references

## References

There are also many small references in the [Glossary](glossary.md).

1.  <a name="ACDict"></a>*American College Dictionary,* Random House, cited in
    [[KnuthDE75](#KnuthDE75)].
2.  <a name="AldrichJ09"></a>Jonathan Aldrich, Joshua Sunshine, Darpan Saini and
    Zachary Sparks, *Typestate-oriented Programming,* In Proceedings of the 24th
    ACM SIGPLAN Conference Companion on Object Oriented Programming Systems
    Languages and Applications (OOPSLA '09) (2009), 1015-1022.
    [DOI link](https://doi.org/10.1145/1639950.1640073).
3.  <a name="BierhoffK05"></a>Kevin Bierhoff and Jonathan Aldrich, *Lightweight
    Object Specification with Typestates,* In Proceedings of the 10th European
    software engineering conference held jointly with 13th ACM SIGSOFT
    international symposium on Foundations of software engineering (ESEC/FSE-13)
    (2005), 217-226. [DOI link](https://doi.org/10.1145/1095430.1081741).
4.  <a name="ClintM72"></a>M. Clint and C. A. Hoare, *Program proving: Jumps and
    functions,* Acta Informatica **1** (1972), no. 3, 214–224.
    [DOI link](https://doi.org/10.1007/BF00288686).
5.  <a name="CoblenzM16"></a>Michael Coblenz, Joshua Sunshine, Jonathan Aldrich,
    Brad Myers, Sam Weber, and Forrest Shull, *Exploring language support for
    immutability,* Proceedings of the 38th International Conference on Software
    Engineering, ICSE ’16, ACM, 2016, pp. 736–747.
    [DOI link](https://doi.org/10.1145/2884781.2884798).
6.  <a name="Crafa2017"></a>Silvia Crafa and Luca Padovani, *The Chemical
    Approach to Typestate-Oriented Programming,* ACM Trans. Program. Lang. Syst.
    **39** (2017), no. 3, 13:1-13:45.
    [DOI link](https://doi.org/10.1145/3064849).
7.  <a name="DeLineR04"></a>DeLine R. and Fähndrich M., *Typestates for
    Objects,* In: Odersky M. (eds) ECOOP 2004 – Object-Oriented Programming,
    ECOOP 2004. Lecture Notes in Computer Science, **3086** (2004), 465-490
    Springer. [DOI link](https://doi.org/10.1007/978-3-540-24851-4_21).
8.  <a name="DesignBcWiki"></a>[Design by contract](https://en.wikipedia.org/wiki/Design_by_contract),
    in *Wikipedia: The Free Encyclopedia*, retrieved 2019-12-11. **Note that
    *Design by contract* may have trademark protection.**
9.  <a name="DijkstraEW72"></a>E.W. Dijkstra, *Notes on structured programming,*
    In Structured Programming (Dalai, Dijkstra, and Hoare, eds.), Academic
    Press, 1972, cited in [[KnuthDE75](#KnuthDE75)].
    [ACM Digital Library link](https://dl.acm.org/citation.cfm?id=1243381).
10. <a name="DosReis18"></a>G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N.
    Myers and B. Stroustrup,
    [Support for contract based programming in C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html),
    in *JTC1/SC22/WG21 - The C++ Standards Committee - ISOCPP*, retrieved
    2019-12-11.
11. <a name="EiffelWiki"></a>[Eiffel programming language](https://en.wikipedia.org/wiki/Eiffel_\(programming_language\)),
    in *Wikipedia: The Free Encyclopedia*, retrieved 2019-12-11.
12. <a name="FindlerRB01"></a>Robert Bruce Findler, Mario Latendresse and
    Matthias Felleisen, *Behavioral Contracts and Behavioral Subtyping,* In
    Proceedings of the 8th European software engineering conference held jointly
    with 9th ACM SIGSOFT international symposium on Foundations of software
    engineering (ESEC/FSE-9). **26** (2001), no. 5, 229-236.
    [DOI link](https://doi.org/10.1145/503271.503240).
13. <a name="GarciaR14"></a>Ronald Garcia, Éric Tanter, Roger Wolff and Jonathan
    Aldrich, *Foundations of Typestate-Oriented Programming,* ACM Trans.
    Program. Lang. Syst. **36** (2014), no. 4, 12:1-12:44.
    [DOI link](https://doi.org/10.1145/2629609).
14. <a name="GordonCS12"></a>Colin S. Gordon, Matthew J. Parkinson, Jared
    Parsons, Aleks Bromfield, and Joe Duffy, *Uniqueness and reference
    immutability for safe parallelism,* In Proceedings of the ACM International
    Conference on Object Oriented Programming Systems Languages and
    Applications, OOPSLA ’12, ACM, 2012, pp. 21–40.
    [DOI link](https://doi.org/10.1145/2384616.2384619).
15. <a name="GstFileSrc"></a> GStreamer plugins code for gstfilesrc.c,
    [gstreamer/plugins/elements/gstfilesrc.c](https://github.com/GStreamer/gstreamer/blob/master/plugins/elements/),
    retrieved 2018-08-01.
16. <a name="KaraormanM99"></a>Murat Karaorman, Urs Hölzle and John L. Bruno,
    *jContractor: A Reflective Java Library to Support Design by Contract,*
    Proceedings of the Second International Conference on Meta-Level
    Architectures and Reflection (Reflection '99) (1999), 175-196.
    Springer-Verlag, Berlin, Heidelberg.
    [DOI link](https://doi.org/10.1007/3-540-48443-4_18).
17. <a name="KnuthDE75"></a>D.E. Knuth, *Ill-chosen use of “event”,*
    Communications of the ACM (ACM Forum) **18** (1975), no. 6, 360.
    [DOI link](https://doi.org/10.1145/360825.360876).
18. <a name="KnuthDE74"></a>Donald E. Knuth, *Structured programming with go to
    statements,* ACM Comput. Surv. **6** (1974), no. 4, 261–301, also cited in
    [[KnuthDE75](#KnuthDE75)].
    [DOI link](https://doi.org/10.1145/356635.356640).
19. <a name="KnuthDE92a"></a>Donald E. Knuth, *Literate programming,* CSLI
    lecture notes, no. 27, Center for the Study of Language and Information,
    Stanford, CA, USA, 1992.
    [ACM Digital library entry](https://dl.acm.org/citation.cfm?id=129057).
20. <a name="KnuthDE92b"></a>Donald E. Knuth, *Structured programming with go to
    statements,* Literate Programming, CSLI lecture notes, no. 27, Center for
    the Study of Language and Information, Stanford, CA, USA, 1992.
21. <a name="LandinPJ65"></a>P. J. Landin, *Correspondence between ALGOL 60 and
    Church’s Lambda-notation: Part I,* Commun. ACM **8** (1965), no. 2, 89–101.
    [DOI link](https://doi.org/10.1145/363744.363749).
22. <a name="ObsidianHome"></a>[Obsidian programming language](https://obsidian-lang.com/),
    homepage retrieved 2019-12-11.
23. <a name="PlaidHome"></a>[Plaid programming language](http://www.plaid-lang.org/),
    homepage, retrieved 2019-12-11.
24. <a name="PosetWiki"></a>[Partially ordered set](https://en.wikipedia.org/wiki/Partially_ordered_set),
    in *Wikipedia: The Free Encyclopedia*, retrieved 2018-11-18.
25. <a name="RacketWiki"></a>[Racket programming language](https://en.wikipedia.org/wiki/Racket_\(programming_language\)),
    in *Wikipedia: The Free Encyclopedia*, retrieved 2019-12-11.
26. <a name="RustBorrowing18"></a>The Rust Project Developers, *The Rust
    Programming Language, section: References and Borrowing,* Rust version
    1.8.0, 2015(?),
    [References and Borrowing](https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html),
    retrieved 2018-10-08.
27. <a name="StricklandTS13"></a>T. Stephen Strickland, Christos Dimoulas, Asumu
    Takikawa and Matthias Felleisen, *Contracts for First-Class Classes,* ACM
    Trans. Program. Lang. Syst. **35** (2013), no. 3, 11:1-11:58.
    [DOI link](https://doi.org/10.1145/2518189).
28. <a name="TorvaldsL14"></a>Linus Torvalds, Dan Carpenter, et al., *Linux
    kernel coding style, ch. 7: Centralized exiting of functions,* Linux Kernel,
    December 2014,
    [Centralized exiting of functions](https://www.kernel.org/doc/html/latest/process/coding-style.html#centralized-exiting-of-functions),
    retrieved 2018-08-01.
29. <a name="TypestateWiki"></a>[Typestate analysis](https://en.wikipedia.org/wiki/Typestate_analysis),
    in *Wikipedia: The Free Encyclopedia*, retrieved 2019-07-16. Last
    substantial revision 2016-12-31.
30. <a name="Wg21Papers2019"></a>
    [JTC1/SC22/WG21 - Papers 2019](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/),
    in *JTC1/SC22/WG21 - The C++ Standards Committee - ISOCPP*, retrieved
    2019-12-11.
31. <a name="WilliamasDO84"></a>David O. Williams, *Structured transfer of
    control,* SIGPLAN Notices **19** (1984), no. 10, 46–51.
    [DOI link](https://doi.org/10.1145/948290.948295).
32. <a name="ZahnCT74"></a>C.T. Zahn, *A control statement for natural top-down
    structured programming,* Proc. of Programming Symposium, Proceedings
    Colloque sur la Programmation (Paris), Lecture Notes in Computer Scienceq,
    vol. 19, Springer-Verlag, April 1974, cited in [[KnuthDE75](#KnuthDE75)].
    [DOI link](https://doi.org/10.1007/3-540-06859-7_133).

## Situations

### Knuth and Zahn's clarification note {#clarification}

Here below is the note [[KnuthDE75](#KnuthDE75)], quoted in entirety, that Knuth
and Zahn wrote as a follow-up to clarify a point from Knuth's 1974 article on
structured programming [[KnuthDE74](#KnuthDE74)].

(We have changed the line breaking in the syntax example to be more like that in
the original article. The columns were quite narrow in ACM Forum. Citations are
reworked for markdown.)

> **Ill-Chosen Use of “Event”**
>
> The recently proposed event-driven case statement [[ZahnCT74](#ZahnCT74)] has
> been described [[ZahnCT74](#ZahnCT74), [KnuthDE74](#KnuthDE74)] in terms of
> “event-indicators” and “event-statements.” A so-called event-statement asserts
> that an indicated event has occurred and the appropriate context is thereby
> immediately terminated.
>
> Further reflection has suggested that our word “event” was ill-chosen. An
> event, in common English usage, is a happening or occurrence associated with a
> passage of time (as the performance of an assignment statement). As such,
> “event” is essentially synonymous with “action” as used by Dijkstra
> [[DijkstraEW72](#DijkstraEW72)]. The discovery at a particular place in a
> program execution that certain variables are in a specified state is better
> described by the word situation which has the dual connotation
> [[ACDict](#ACDict)] of “state of affairs” and “place or locality.”
>
> We would, therefore, like to propose that this control statement be called the
> “situation case statement” with situation-indicators denoted by identifiers
> &lt;situation<sub>k</sub>&gt;, and perhaps with the following syntax.
>
> **until** &lt;situation<sub>1</sub>&gt; **or** &lt;situation<sub>2</sub>&gt;
> ... **or** &lt;situation<sub>n</sub>&gt;: \
> &emsp;&emsp;&lt;statement<sub>0</sub>&gt; \
> **then case** \
> &emsp;&emsp;**begin**
> &lt;situation<sub>1</sub>&gt;:&lt;statement<sub>1</sub>&gt;; \
> &emsp;&emsp;&emsp;&emsp;&#x22EE; \
> &emsp;&emsp;&emsp;&emsp;&lt;situation<sub>n</sub>&gt;:&lt;statement<sub>n</sub>&gt;;
> \
> &emsp;&emsp;**end**
>
> Within &lt;statement<sub>0</sub>&gt; a situation statement denoted by the
> appropriate situation indicator causes &lt;statement<sub>0</sub>&gt; to be
> immediately terminated and the appropriate case selection to be performed.
> More generally, parameters can usefully be introduced into the situation
> statements and into the corresponding parts of the case clause; see
> [[KnuthDE74](#KnuthDE74)].
>
> It is interesting to note that the word “event” seems to also be improperly
> used in many discussions of concurrent processes and their mutual
> synchronization. Processes must usually defer their activity until particular
> conditions or situations arise. Some clarity might be gained by consistently
> using the words condition, situation, and event, as follows:
>
> condition ≡ a state of affairs involving program variables \
> situation ≡ a condition occurring at a particular location in a program
> execution \
> event ≡ the occurrence of some action usually altering the state of program
> variables.
>
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Donald E. Knuth \
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Charles T. Zahn Jr. \
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Stanford University \
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Stanford, CA 94305

### Linux coding style {Linux-kernel}

This is a section, [Centralized exiting of functions](#TorvaldsL14), from the
Linux kernel coding style document. Formatting preserved as best as possible.

> **Centralized exiting of functions**
>
> Albeit deprecated by some people, the equivalent of the goto statement is used
> frequently by compilers in form of the unconditional jump instruction.

> The goto statement comes in handy when a function exits from multiple
> locations and some common work such as cleanup has to be done. If there is no
> cleanup needed then just return directly.
>
> Choose label names which say what the goto does or why the goto exists. An
> example of a good name could be `out_free_buffer:` if the goto frees `buffer`.
> Avoid using GW-BASIC names like `err1:` and `err2:`, as you would have to
> renumber them if you ever add or remove exit paths, and they make correctness
> difficult to verify anyway.
>
> The rationale for using gotos is:
>
> *   unconditional statements are easier to understand and follow
> *   nesting is reduced
> *   errors by not updating individual exit points when making modifications
>     are prevented
> *   saves the compiler work to optimize redundant code away ;)
>
> ```
> int fun(int a)
> {
>         int result = 0;
>         char *buffer;
>
>         buffer = kmalloc(SIZE, GFP_KERNEL);
>         if (!buffer)
>                 return -ENOMEM;
>
>         if (condition1) {
>                 while (loop1) {
>                         ...
>                 }
>                 result = 1;
>                 goto out_free_buffer;
>         }
>         ...
> out_free_buffer:
>         kfree(buffer);
>         return result;
> }
> ```
>
> A common type of bug to be aware of is one err bugs which look like this:
>
> ```
> err:
>         kfree(foo->bar);
>         kfree(foo);
>         return ret;
> ```

> The bug in this code is that on some exit paths foo is NULL. Normally the fix
> for this is to split it up into two error labels `err_free_bar:` and
> `err_free_foo:`:
>
> ```
> err_free_bar:
>        kfree(foo->bar);
> err_free_foo:
>        kfree(foo);
>        return ret;
> ```
>
> Ideally you should simulate errors to test all exit paths.

### GStreamer example {GStreamer}

> `gst_file_src_start`, excerpt, from [gstfilesrc.c](#GstFileSrc).
>
> ```
>   458 /* open the file, necessary to go to READY state */
>   459 static gboolean
>   460 gst_file_src_start (GstBaseSrc * basesrc)
>   461 {
>   462   GstFileSrc *src = GST_FILE_SRC (basesrc);
>   463   struct stat stat_results;
>   464
>   465   if (src->filename == NULL || src->filename[0] == '\0')
>   466     goto no_filename;
>   467
>   468   GST_INFO_OBJECT (src, "opening file %s", src->filename);
>   469
>   470   /* open the file */
>   471   src->fd = gst_open (src->filename, O_RDONLY | O_BINARY, 0);
>   472
>   473   if (src->fd < 0)
>   474     goto open_failed;
>   475
>   476   /* check if it is a regular file, otherwise bail out */
>   477   if (fstat (src->fd, &stat_results) < 0)
>   478     goto no_stat;
>   479
>   480   if (S_ISDIR (stat_results.st_mode))
>   481     goto was_directory;
>   482
>   483   if (S_ISSOCK (stat_results.st_mode))
>   484     goto was_socket;
>   485
>   486   src->read_position = 0;
>   487
>   488   /* record if it's a regular (hence seekable and lengthable) file */
>   489   if (S_ISREG (stat_results.st_mode))
>   490     src->is_regular = TRUE;
>   491
>   492   /* We need to check if the underlying file is seekable. */
>   493   {
>   494     off_t res = lseek (src->fd, 0, SEEK_END);
>   495
>   496     if (res < 0) {
>   497       GST_LOG_OBJECT (src, "disabling seeking, lseek failed: %s",
>   498           g_strerror (errno));
>   499       src->seekable = FALSE;
>   500     } else {
>   501       res = lseek (src->fd, 0, SEEK_SET);
>   502
>   503       if (res < 0) {
>   504         /* We really don't like not being able to go back to 0 */
>   505         src->seekable = FALSE;
>   506         goto lseek_wonky;
>   507       }
>   508
>   509       src->seekable = TRUE;
>   510     }
>   511   }
>   512
>   513   /* We can only really do seeking on regular files - for other file types, we
>   514    * don't know their length, so seeking isn't useful/meaningful */
>   515   src->seekable = src->seekable && src->is_regular;
>   516
>   517   gst_base_src_set_dynamic_size (basesrc, src->seekable);
>   518
>   519   return TRUE;
>   520
>   521   /* ERROR */
>   522 no_filename:
>   523   {
>   524     GST_ELEMENT_ERROR (src, RESOURCE, NOT_FOUND,
>   525         (_("No file name specified for reading.")), (NULL));
>   526     goto error_exit;
>   527   }
>   528 open_failed:
>   529   {
>   530     switch (errno) {
>   531       case ENOENT:
>   532         GST_ELEMENT_ERROR (src, RESOURCE, NOT_FOUND, (NULL),
>   533             ("No such file \"%s\"", src->filename));
>   534         break;
>   535       default:
>   536         GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
>   537             (_("Could not open file \"%s\" for reading."), src->filename),
>   538             GST_ERROR_SYSTEM);
>   539         break;
>   540     }
>   541     goto error_exit;
>   542   }
>   543 no_stat:
>   544   {
>   545     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
>   546         (_("Could not get info on \"%s\"."), src->filename), (NULL));
>   547     goto error_close;
>   548   }
>   549 was_directory:
>   550   {
>   551     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
>   552         (_("\"%s\" is a directory."), src->filename), (NULL));
>   553     goto error_close;
>   554   }
>   555 was_socket:
>   556   {
>   557     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ,
>   558         (_("File \"%s\" is a socket."), src->filename), (NULL));
>   559     goto error_close;
>   560   }
>   561 lseek_wonky:
>   562   {
>   563     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL),
>   564         ("Could not seek back to zero after seek test in file \"%s\"",
>   565             src->filename));
>   566     goto error_close;
>   567   }
>   568 error_close:
>   569   close (src->fd);
>   570 error_exit:
>   571   return FALSE;
>   572 }
> ```

## Reach and rights {#reach}

We will expand this, for now just some references.

Research includes:

*   This [useful overview article](#CoblenzM16), which considers the interesting
    work in [this immutability article](#GordonCS12), which was one of the
    sources that triggered the thinking that led to this project.

Perhaps the most worked-out and polished example of reachability (via
*borrowing*) is:

*   The section [References and Borrowing](#RustBorrowing18) in *The Rust
    "book"*.

## Prior work on typestate, constraints and contracts {#typecontracts}

*These are just some initial notes. There are lots of angles to this, and it is
hard to capture it all.*

Patinon treats typestate and contracts together, whereas in the literature they
have been treated somewhat separately. See
[the semi-glossary](semigloss.md#fielding) for more detail.

In the citations and links that follow, we sometimes reference a Wikipedia page
instead of, say, directly linking to a project homepage. This is because the
Wikipedia page may be kept up to date, and it will have additional links. Also
note that the [Typestate analysis](#TypestateWiki) wiki page is a bit weak.
Other pages relevant to Patinon are typically stronger.

### Typestate research {#typeresearch}

While prior research into typestate has often focused on capabilities,
permissions have been explored as well. Typestate has most often been considered
as an accessory, but has also been explored as core to a programming language.

A quick list.

*   Programming languages: [Plaid programming language](#PlaidHome),
    [Obsidian programming language](#ObsidianHome).
*   Miscellaneous references:
    *   [Garcia, et al., *Foundations of Typestate-Oriented Programming*](#GarciaR14),
    *   [Aldrich, et al., *Typestate-oriented Programming*](#AldrichJ09),
    *   [Kevin Bierhoff and Jonathan Aldrich, *Lightweight Object Specification
        with Typestates*](#BierhoffK05),
    *   [DeLine and Fähndrich, *Typestates for Objects*](#DeLineR04),
    *   [Crafa and Padovani, *The Chemical Approach to Typestate-Oriented
        Programming*](#Crafa2017).

### Contracts research {#contractsresearch}

Much research into contracts has treated them, quite successfully, as
accessories. In other cases contracts have been part of the basis for a language
design. Some projects have focused on compile-time checks, others on run-time
checks.

Early on, Patinon may not make invariants explicit, in contrast with prior work.
Nonetheless, some invariants will be tracked. For example, we envisage
persistent container typestates. So inserting a new element into a hash map does
not change what is got from an existing key. In other words, the content
returned by a valid key does not change on an insertion. That said, some of the
concerns about breaking invariants are different in Patinon because it deals
more with inequalities of typestates than equalities (which requires a long
discussion). Another invariant that might be considered if Patinon gets to an
advanced stage is that of keyed isolation. A hash map might have a typestate
property attached that requires and assures that the content returned from two
different keys are mutually isolated.

*   Programming languages: [Eiffel programming language](#EiffelWiki),
    [Racket programming language](#RacketWiki).
*   [Design by contract](#DesignBcWiki). Also known as *DbC*. In Patinon *design
    with contracts* is to be preferred, because it is not a design methodology.
    Also the term may be under some trademark proscription
    rights[^proscription].
*   Miscellaneous references:
    *   [Murat Karaorman, Urs Hölzle and John L. Bruno, *jContractor: A
        Reflective Java Library to Support Design by Contract*](#KaraormanM99),
    *   [Robert Bruce Findler, Mario Latendresse and Matthias Felleisen,
        *Behavioral Contracts and Behavioral Subtyping*](#FindlerRB01),
    *   [Strickland, et al., *Contracts for First-Class Classes,* ](#StricklandTS13).
*   C++20 references:
    *   [Dos Reis, et al., *Support for contract based programming in C++*](#DosReis18),
    *   [JTC1/SC22/WG21 - Papers 2019](#Wg21Papers2019).

[^proscription]: Usage of the term *Design by contract* may be proscribed
    (limited) because of trademark registration.
