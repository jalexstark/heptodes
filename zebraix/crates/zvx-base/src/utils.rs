// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{CubicHomog, CubicPath, RatQuadHomog, RatQuadHomogPower, RatQuadHomogWeighted};
use approx::AbsDiffEq;

#[derive(PartialEq, Debug)]
pub struct F64SliceWrapped<'a, const N: usize> {
   v: &'a [f64; N],
}

impl<'a, const N: usize> From<&'a [f64; N]> for F64SliceWrapped<'a, N> {
   fn from(unwrapped: &'a [f64; N]) -> Self {
      F64SliceWrapped::<N> { v: unwrapped }
   }
}

#[allow(clippy::elidable_lifetime_names)]
impl<'a, const N: usize> AbsDiffEq for F64SliceWrapped<'a, N> {
   type Epsilon = f64;

   fn default_epsilon() -> f64 {
      1.0e-06
   }

   fn abs_diff_eq(&self, other: &Self, epsilon: f64) -> bool {
      for i in 0..N {
         if !f64::abs_diff_eq(&self.v[i], &other.v[i], epsilon) {
            return false;
         }
      }
      true
   }
}

// This probably should be generalized and merged with `Curve<>`.
trait HomogContainer<'a> {
   type Homog;
   type HomogWrapped;
   fn h(&'a self) -> &'a Self::Homog;
   fn r(&self) -> [f64; 2];
   fn sigma(&self) -> (f64, f64);
}

#[derive(PartialEq, Eq, Debug)]
pub struct PathWrapped<'a, P> {
   v: &'a P,
}

impl<'a, P: HomogContainer<'a> + std::cmp::PartialEq> From<&'a P> for PathWrapped<'a, P> {
   fn from(unwrapped: &'a P) -> Self {
      PathWrapped::<P> { v: unwrapped }
   }
}

impl<'a> HomogContainer<'a> for CubicPath {
   type Homog = CubicHomog;
   type HomogWrapped = CubicHomogWrapped<'a>;
   #[inline]
   fn h(&'a self) -> &'a CubicHomog {
      &self.h
   }
   #[inline]
   fn r(&self) -> [f64; 2] {
      self.r
   }
   #[inline]
   fn sigma(&self) -> (f64, f64) {
      self.sigma
   }
}

impl<'a> HomogContainer<'a> for RatQuadHomogPower {
   type Homog = RatQuadHomog;
   type HomogWrapped = RatQuadHomogWrapped<'a>;
   #[inline]
   fn h(&'a self) -> &'a RatQuadHomog {
      &self.h
   }
   #[inline]
   fn r(&self) -> [f64; 2] {
      self.r
   }
   #[inline]
   fn sigma(&self) -> (f64, f64) {
      self.sigma
   }
}

impl<'a> HomogContainer<'a> for RatQuadHomogWeighted {
   type Homog = RatQuadHomog;
   type HomogWrapped = RatQuadHomogWrapped<'a>;
   #[inline]
   fn h(&'a self) -> &'a RatQuadHomog {
      &self.h
   }
   #[inline]
   fn r(&self) -> [f64; 2] {
      self.r
   }
   #[inline]
   fn sigma(&self) -> (f64, f64) {
      self.sigma
   }
}

#[allow(clippy::elidable_lifetime_names)]
impl<'a, P> AbsDiffEq for PathWrapped<'a, P>
where
   P: HomogContainer<'a> + std::cmp::PartialEq,
   P::HomogWrapped: From<&'a P::Homog> + AbsDiffEq,
   <P::HomogWrapped as AbsDiffEq>::Epsilon: From<f64>,
{
   type Epsilon = f64;

   fn default_epsilon() -> f64 {
      1.0e-06
   }

   fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
      // epsilon_wrap is typically an f64 generated by pass-through of an f64.
      let epsilon_wrap =
         <<P as HomogContainer<'a>>::HomogWrapped as AbsDiffEq>::Epsilon::from(epsilon);
      P::HomogWrapped::from(self.v.h())
         .abs_diff_eq(&P::HomogWrapped::from(other.v.h()), epsilon_wrap)
         && F64SliceWrapped::from(&self.v.r())
            .abs_diff_eq(&F64SliceWrapped::from(&other.v.r()), epsilon)
         && self.v.sigma().0.abs_diff_eq(&other.v.sigma().0, epsilon)
         && self.v.sigma().1.abs_diff_eq(&other.v.sigma().1, epsilon)
   }
}

#[derive(PartialEq, Debug)]
pub struct CubicHomogWrapped<'a> {
   v: &'a CubicHomog,
}

impl<'a> From<&'a CubicHomog> for CubicHomogWrapped<'a> {
   fn from(unwrapped: &'a CubicHomog) -> Self {
      CubicHomogWrapped { v: unwrapped }
   }
}

#[allow(clippy::elidable_lifetime_names)]
impl<'a> AbsDiffEq for CubicHomogWrapped<'a> {
   type Epsilon = f64;

   fn default_epsilon() -> f64 {
      1.0e-06
   }

   fn abs_diff_eq(&self, other: &Self, epsilon: f64) -> bool {
      for k in 0..2 {
         if !F64SliceWrapped::<4>::abs_diff_eq(
            &F64SliceWrapped::<4>::from(&self.v.0[k]),
            &F64SliceWrapped::<4>::from(&other.v.0[k]),
            epsilon,
         ) {
            return false;
         }
      }
      true
   }
}

#[derive(PartialEq, Debug)]
pub struct RatQuadHomogWrapped<'a> {
   v: &'a RatQuadHomog,
}

impl<'a> From<&'a RatQuadHomog> for RatQuadHomogWrapped<'a> {
   fn from(unwrapped: &'a RatQuadHomog) -> Self {
      RatQuadHomogWrapped { v: unwrapped }
   }
}

#[allow(clippy::elidable_lifetime_names)]
impl<'a> AbsDiffEq for RatQuadHomogWrapped<'a> {
   type Epsilon = f64;

   fn default_epsilon() -> f64 {
      1.0e-06
   }

   fn abs_diff_eq(&self, other: &Self, epsilon: f64) -> bool {
      for k in 0..3 {
         if !F64SliceWrapped::<3>::abs_diff_eq(
            &F64SliceWrapped::<3>::from(&self.v.0[k]),
            &F64SliceWrapped::<3>::from(&other.v.0[k]),
            epsilon,
         ) {
            return false;
         }
      }
      true
   }
}
